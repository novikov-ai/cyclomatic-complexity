# Уменьшение ЦС функций:
- [Пример 1](example-one/README.md)
- [Пример 2](example-two/README.md)
- [Пример 3](example-three/README.md)

# Выводы

В ходе практики по уменьшению цикломатической сложности (ЦС) функций, познакомился с полезным инструментом, позволяющим мгновенно посчитать ЦС для функций конкретной директории или всего проекта:
`https://github.com/fzipp/gocyclo`

~~~
gocyclo .
~~~

Обязательно буду проверять свои будущие функции на ЦС, это не занимает много времени, но уверен, что позволит сделать код более выразительным.

Хорошей практикой будет сделать проверку ЦС на уровне линтера, который будет запрещать деплой при превышении порогового значения ЦС функции.

Интересно, что ЯП Go практически "из коробки", прививает правильный стиль программирования:
- Например, есть негласное правило в сообществе разработчиков: не использовать ветвления через else
- Удобный механизм для работы с коллекциями (range) позволяет избегать циклов
- К сожалению, удобной работы с ad hoc полиморфизмом нет, как в классических ЯП ООП, но его можно реализовать при помощи интерфейса, который реализуют, например, другие типы

Интересно думать про разрабатываемую функцию как прямую дорогу, по которой нужно пройти, тогда как любые ветвления от нее уводят нас в сторону.

Хорошее упражнение, про которое захотелось написать статью - реализация задачи FizzBuzz без условий. Сначала я не понимал как это возможно, 
но когда стал думать про функцию, которая никуда не сворачивает и является прямолинейной, то решение само нашлось:
~~~
func FizzBuzz(n int) {
	ff := make([]interface{}, n, n)

	for i := 0; i < n; i++ {
		ff[i] = i + 1
	}

	for i := 2; i < n; i += 3 {
		ff[i] = "Fizz"
	}

	for i := 4; i < n; i += 5 {
		ff[i] = "Buzz"
	}

	for i := 14; i < n; i += 15 {
		ff[i] = "FizzBuzz"
	}

	for _, f := range ff {
		fmt.Printf("%v\n", f)
	}
}
~~~

Полагаю основной мой инструмент по уменьшению ЦС - написание чистых функций и, по возможности, применение полиморфизма.

Главное - не забывать правило: мы гораздо чаще читаем код, чем его пишем. Поэтому делаем все, чтобы код был выразительным и удобным в поддержке.

